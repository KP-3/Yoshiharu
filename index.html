<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!--
   デフォルトのスタイル
   より見やすく変更しても良い
  -->
  <link rel="stylesheet" href="default.css"/>

  <!--
    SyntaxHighlighter 3.0.83 (http://alexgorbatchev.com/SyntaxHighlighter/)
    Java のコードを読みやすくする
  -->
  <link rel="stylesheet" href="shCore.css"/>
  <link rel="stylesheet" href="shThemeDjango.css"/>
  <script src="shCore.js"></script>
  <script src="shBrushJava.js"></script>
  <script>SyntaxHighlighter.all();</script>

  <!--
    目次を動的に生成する
  -->
  <script src="outliner.js"></script>
  <script>
    window.addEventListener('load', function() {
      // 第一引数: アウトライン対象の要素のセレクタ，第二引数: アウトラインを格納する要素のセレクタ．
      new TOutliner('h2', '#outline');
    });
  </script>

  <title>知能プログラミング演習II レポート</title>
</head>

<body>
<header>
  <!-- グループ番号・学籍番号・名前を書く．-->
  <h1>グループ1 27115157 横尾由春</h1>

  <!-- 目次生成用 -->
  <nav id="outline"></nav>
</header>

<h2>グループ</h2>
グループ作成書類: <a href="../Grep6/index.html">GrepX</a><br>
メンバーと役割分担: 
<ul>
<li><a href="../../../../ckl15076/workspace/kprep/rep6/index.html">鈴木祥太 27115076</a>: 課題6-2担当，</li>
<li><a href="../../../../ckl15077/workspace/kprep/rep6/index.html">鈴木進也 27115077</a>: 課題6-3 ,課題6-5 GUI実装担当</li>
<li><a href="../../../../ckl15120/workspace/kprep/rep6/index.html">丹羽貴敏 27115120</a>: 課題6-2担当，</li>
<li><a href="../../../../ckl15157/workspace/kprep/rep6/index.html">横尾由春 27115157</a>: 課題6-1 ,課題6-4担当</li>
</br>
課題振り分けを上記の通り行った。6-2にメンバーの半分を割り当てている理由は唯一のプログラムを作成する課題であるからである。</br>
またGUI作成(基本、発展含む)を1人に割り当てた。</br>

</ul>

<h2>ソースファイル</h2>
<ul>

    <!-- 実装・変更したソースファイルへのリンク．修正する． -->
    <!-- ※ リンクは絶対パスに変更せず，上記のような相対パスのままで！ -->
</ul>

<hr>

<h2>課題6-1</h2>
<!-- 課題を書く．-->
[必須課題6-1] まず，教科書3.2.1の「前向き推論」のプログラムと教科書3.2.2の「後向き推論」のプログラムとの動作確認をし，前向き推論と後ろ向き推論の違いを説明せよ．また，実行例を示してルールが選択される過程を説明せよ．説明の際には，ドロー系ツール（LibreOfficeのDrawやTgifなど）を使ってp.106 図3.11やp.118 図3.12のような図として示すことが望ましい．


<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->
なし。

<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
なし。


<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
前向き推論と後ろ向き推論の違いは考察で述べる。</br>



<h3>実行例</h3>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
<b>・前向き推論</b></br>
講義で与えられたデータセットでは量が多すぎるため、ここでは以下のようにデータ(ワーキングメモリ)、ルールを定義し推論の説明を行う。</br>
</br>
</br>
データ</br>
<li>1...my-car is inexpensive</li>
<li>2...my-car has an aluminium body</li>
<li>3...my-car has only 2 seats</li>
<li>4...my-car has a VTEC engine</li>
</br>
</br>
ルール</br>
<li>
<b>rule</b>&emsp; 	"CarRule1"</br>
<b>if</b>&emsp;&emsp;	"?x is made in Japan"</br>
&emsp;&emsp;&emsp;	"?x has a VTEC engine"</br>
<b>then</b>&emsp; 	"?x is a Honda"</br></li></br>
<li><b>rule</b>&emsp; 	"CarRule2"</br>
<b>if</b>&emsp;&emsp;	"?x is inexpensive"</br>
<b>then</b>&emsp; 	"?x is made in Japan"</br>
</li>
</br>
<li><b>rule</b>&emsp; 	"CarRule3"</br>
<b>if</b>&emsp;&emsp;	"?x has an aluminium body"</br>
&emsp;&emsp;&emsp;	"?x has only 2 seats"</br>
<b>then</b>&emsp; 	"?x is a NSX"</br></li></br>

上のようにルール、データを変更した上で、前向き推論を行った結果以下のような結果を得た。</br>

<!-- 画像ファイルを貼る場合は <img> タグを使う -->
<img src="./6-1.png"/></br>
この実行例を基に説明を行う。</br></br>
<b>1巡目</b></br>
<p>
はじめに、CarRule1の前文とデータが一致するかどうかの判定を行う。</br>
今回の例ではCarRule1の前文(2つ)ともマッチする文章がデータには存在しない。このルールによってワーキングメモリにデータが追加されることはない。</br>
よってCarRule1の探索が終了し、次のルールであるCarRule2の探索を行う。</br></p><p>
CarRule2の前件は、1番目のデータ"my-car is inexpensive"とマッチングする(トリガ)。マッチング判定がtrueとなると、さらに
CarRule2の後件の文章("?x is made in Japan")がワーキングメモリに存在するかどうかの判定を行う。</br>
今回は存在しないので、後件の文章("?x is made in Japan")がワーキングメモリに追加され、</br>
"Success: my-car is made in Japan"</br>
が出力される。</br>
ここでCarRule2の探索は終了となる。</p>

どこかのルールでtrueとなっても、ルールの探索は引き続き行われる。よってワーキングメモリを引き継いだままCarRule3の探索を開始する。</br>
<p>
CarRule3の前件とデータはマッチングしないため、データの追加が行われることはない。</br>
ここでCarRule3の探索が終了となる。</br>
</p>
<p>
すべてのルールの探索が終わったため、この巡でワーキングメモリに新たなアサーションが追加されたかどうかを調べる。</br>
今回はCarRule2で"my-car is made in Japan"が追加されたため、trueとなる。trueとなった場合、再度ルールの探索をはじめから開始する。</br>

</p>
</br>
<b>2巡目</b></br>
<p>
再度、CarRule1から探索を開始する。</br>
今回は、ワーキングメモリにはじめから格納されている"my-car is made in Japan","my-car has a VTEC engine",に加えて1巡目でワーキングメモリに追加された"my-car is made in Japan"によってルールCarRule1がトリガされる。</br>
1巡目では"my-car is made in Japan"がワーキングメモリに格納されていなかったため、ルールCarRule1はトリガされることはなかった。</br>
CarRule1の後件のアサーションである"my-car is a Honda"はワーキングメモリに格納されていないため、このアサーションはワーキングメモリに無事格納される。</br></p>
すべてのルールの探索が終わったため、再度この巡でワーキングメモリに新たなアサーションが追加されたかどうかを調べる。</br><p>
CarRule2もワーキングメモリに前件のアサーションが格納されているので、トリガされる。</br>
しかし、ワーキングメモリに後件の文章"my-car is made in Japan"が既に格納されているため、新たに格納されることはなく、CarRule2の処理が終了する。</p>
CarRule3は1巡目と同様にマッチング判定を行うが、トリガされることなく2巡目は終了している。</br>
アサーション追加判定は、今回もCarRule1で"my-car is a Honda"が追加されたため、trueとなる。</br>
</p></br>
<b>3巡目</b></br>
<p>
再度、CarRule1から探索を開始する。</br>
CarRule1はトリガされるが、"my-car is a Honda"は既にワーキングメモリに格納されているため、新たに追加されることはない。</br>
また今回も、はじめから格納されている"my-car has an aluminium body","my-car has only 2 seats",に加えて2巡目でワーキングメモリに追加された"my-car is a Honda"によってルールCarRule2がトリガされる。</br>
CarRule2の後件のアサーションである"my-car is a NSX"はワーキングメモリに格納されていないため、このアサーションが格納される。</br></p>
CarRule3は1巡目と同様にマッチング判定を行うが、トリガされることなく3巡目は終了している。</br>
今回もアサーション追加判定はtrueとなる。</br>
</br>
<b>4巡目</b></br>
<p>
再度、CarRule1から探索を開始する。</br>
CarRule1,CarRule2,CarRule3それぞれトリガは起こるが、全てのルールの後件がワーキングメモリに存在するため、新たに格納されることはない。</br>
よって、アサーション追加判定はfalseとなり、推論は終了する。</br>

</br>
</br>
</p>
また視覚的に推論を表すと以下のようになる。</br>
<img src="./figure.png"style="width:60%"></br>

<b>・後ろ向き推論</b></br>

今回も簡単のため、質問を"?x is an Accord Wagon"ではなく"?x is a Honda"とする。</br>
また、ルールからCarRule7を取り除き推論を行う。</br>
</br>
以上のように設定した後、プログラムを実行すると、以下のような結果を得た。</br>
<img src="./6-2.png"></br>
この実行例を基に説明を行う。</br></br>
</br>
<b>手順1</b></br>
<p>
与えられた仮説は"?x is a Honda"である。これと照合するワーキングメモリのアサーションは存在しないため、ルールを使って仮説を置き換える。</br>
まずCarRule8の後件が仮説と照合する。</br>
このトリガにより、仮説が"?x6 is made in Japan","?x6 has a VTEC engine"に置き換わる。</br>
手順2以降これらを証明する方針となる。</br>
手順1終了時の仮説リスト:["?x6 is made in Japan","?x6 has a VTEC engine"]</br>
</br>
</p>
<b>手順2</b></br>
<p>
手順1によって置き換わった仮説をアサーション、ルールの後件と照合する。照合した結果"?x6 is made in Japan"はCarRule1と照合、"?x6 has a VTEC engine"はワーキングメモリと照合する。"?x6 is made in Japan"はルールとの照合のため前件である"?x7 is inexpensive"と置き換わる。</br>
"?x6 has a VTEC engine"はワーキングメモリの"his-car has a VTEC engine"と照合されるため、事実と結びついたことになる。</br>
手順2終了時の仮説リスト:["?x7 is inexpensive"]</br></p></br>
<b>手順3</b></br>
<p>
最後に手順2終了時の仮説リスト"?x7 is inexpensive"を証明する。</br>
ワーキングリスト内の"his-car is inexpensive"と照合されるため、これも事実として認められる。</br>
これにより、仮説全てを証明したことになり、与えられた質問"?x is a Honda"はtrue,{?x=his-car}を得る。</br>
</p>
</br>
</br>
また視覚的に推論を表すと以下のようになる。</br>
<img src="./figure2.png"style="width:60%"></br>
<h2>課題6-4</h2>
<!-- 課題を書く．-->
[必須課題6-4] グループでの進捗管理や成果物共有などについて，工夫した点や使ったツールについて，グループ作成書類で考察せよ．
<h3>独自仕様の説明</h3>
<!--
 もし自分で独自に決めた仕様があれば，その説明を書く．
-->
なし。
<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
なし。
<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
なし。
<h3>実行例</h3>
なし。
<h2>考察</h2>
<!--
 考察を書く．PNGやGIF等の絵を張っても良い．
 例: 自分で工夫して解決した点，その解決手法，なぜそうしたのか，その手法の素晴らしさ，上手くいかなかった点，なぜ上手くいかなかったのか，など．
 例: 今回はできなかったが，更に〜の機能を追加すべきである．なぜなら，...
-->
<b>課題6-1</b></br>
<h4>・前向き推論とは</h4>
<p>
前向き推論とは使用可能なデータ(ワーキングメモリ)から、与えられたルールを用いてデータを増やし、最終解を得るまで推論を行う推論方法である。</br>
主にルールともとあるデータから新たな事実を増やしていくことで推論を進める。</br>
この推論方法は使用可能なデータからスタートし、推論規則を使って最適解に達するまでさらにデータを引き出していく。前向き推論を使う推論方法は、推論規則の前件を検索し、前件部（IF節）が真であることが分かっている規則を探し出す。見つけた規則の後件部（THEN節）は、データセットへの新たな情報として追加される。
</br>

</p>
</br>
<h4>・後ろ向き推論とは</h4>
<p>
後ろ向き推論とは仮説の真偽を、与えられたルールを用いて導く推論方法である。</br>
仮説を与えられたルールを用いて解釈を行うことで推論を進める。</br>
推論方法は推論規則を検索し、ルールの後件（THEN節）がゴールにマッチする規則を探す。その規則の前件部（IF節）が真かどうか不明な場合、それもゴールのリストに追加され（つまり、仮説の一部とされ）、それを立証するデータをさらに導き出さなければならない。
</p>
</br>
<h4>・前向き推論と後ろ向き推論の違い</h4>
<p>
1.使用可能データ(事実)とゴール(仮説)</br>
前向き推論では徐々に使用可能データは増えることになるが、後ろ向き推論では始めに与えられたデータから増えることはなく一定を保つ。これは前向き推論では導き出されるものは事実であり、最適解を得る過程でその事実を再度用いることができるからである。</br>
一方後ろ向き推論ではワーキングメモリ(使用可能データ)が増えることはない。理由は後ろ向き推論で得る情報は事実ではなく、その段階では仮説であるからである。</br>
しかし、後ろ向き推論ではゴール(仮説)が増えていくことになる。これはゴールが後件部とマッチングした場合、ルールの規則の前件部が全て使用可能データとマッチングするか確かめる必要があるからである。IF節が2つ以上存在する際に一度保存しておく必要がでてくるため、リストで保管する。</br>
よって、推論によって事実が増えるのが前向き推論であり、仮説が増えるのが後ろ向き推論である。</br></p>
</br>
<p>
2.ルールの扱い</br>
前向き推論ではルールの前件部とデータのマッチングを行い、trueならば後件部をワーキングリストに代入する。</br>
しかし後ろ向き推論でははじめにマッチングさせるのは後件部であり、前件部を得ることになる。</br>
前向き推論では事実を増やし推論を進めるので後件部を多く得ることになるが、後ろ向き推論は仮説の解釈を進めるのが目的であるので前件部を得ることになる。</br>

</p>
</br>
</br>
</br>
<b>課題6-4</b></br>
<p>グループ3では、進捗管理等をLINEを使って管理し、データ、プログラム等の共有をGitHubを用いて管理することにした。</br></p><p>
LINEを用いる理由は、
<li>文章で共有する情報は使い慣れているLINEで十分</li>
<li>スケジュール調整等のツールが豊富</li>
等が挙げられる。</br></br></p>
<p>またGitHubを選んだ理由は、
<li>候補(GitHub,Slack,Trello,Redmine)の中でも聞き覚えがある。</li>
<li>このツールを使っている先輩を知っている。</li>
等が挙げられる。</br>
</p>
</br>
Githubでは、グループを作成しグループ内にリポジトリを作成、その中のファイルを自由に変更できるようにした。</br>
Githubは、グループを作成しそのなかでファイルを管理するため、グループで認められたメンバーのみが共有ファイルにアクセスできる。</br>
<hr>


<h2>感想</h2>
<!-- 感想を書く．-->
<!-- 例: 〜が面白かった，〜がわからなかった，〜を作ってみたい，講義・演習に関する要望，など．-->
<p>
今までの個人課題と比べて躓いたときに相談、協力しあえた分精神的にも良い環境で課題を進めることができた。またクオリティも個人課題と比べて高いものができたと思う。
</p>


<h2>参考文献</h2>
<!-- 参考文献を書く．助けてもらった人がいれば，それも書く-->

<ul>
  <li>グループ3のメンバー</li>
  <li>新谷虎松 著（19XX）『知能プログラミング入門』コロナ社</li>
</ul>

</body>
</html>
